<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hu | Hron's blog]]></title>
  <link href="http://hron.me/blog/tags/hu/atom.xml" rel="self"/>
  <link href="http://hron.me/"/>
  <updated>2013-01-30T17:38:09+01:00</updated>
  <id>http://hron.me/</id>
  <author>
    <name><![CDATA[Gábor Garami]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nginx - Bevezetés]]></title>
    <link href="http://hron.me/blog/2013/01/nginx-bevezeto/"/>
    <updated>2013-01-21T17:51:00+01:00</updated>
    <id>http://hron.me/blog/2013/01/nginx-bevezeto</id>
    <content type="html"><![CDATA[<p>Ezen cikk a tervek szerint egy sorozat része lesz, amely majd szép lassan (ahogy időm engedi) kerül ki a blogra.</p>

<p>Lássuk tehát az első részt, mely - ahogy a cím is utal rá - egyfajta általános bemutatása lesz ennek a pici webszervernek.</p>

<h2>Mi az Nginx?</h2>

<p>Az <a href="http://www.nginx.org/">Nginx</a> neve az angol Engine X (X motor) kifejezésből származik, ejteni is eszerint kell, tehát <code>ˈen-jən eks</code>.</p>

<p>Magát a motort egy Igor Sysoev nevű srác fejleszti 2002 óta, a kód maga 2004-ben lett nyilvános. Az elsődleges cél egy
pehelysúlyú, ugynakkor skálázható webszerver létrehozása volt, mely képes egy online tartalomszolgáltatónál felmerülő legtöbb
problémával megbirkózni, például az ún. C10K problémával, a legtöbb akkori webszervernek ugyanis problémát okozott egyidejűleg több,
mint 10 000 kapcsolatot kezelni.</p>

<p>Jelenleg az Nginx a világ harmadik legnépszerűbb webszervere, a <a href="http://news.netcraft.com/archives/2012/">2012-es NetCraft felmérés</a> szerint az összes mért oldal 12.07%-át
Nginx segítségével szolgálják ki.</p>

<h2>Az Nginx előnyei</h2>

<p>De mi teszi oly népszerűvé ezt a furcsa nevű webszervert? Mi az, amiért egyre-másra jelennek meg leírások, tutorialok hozzá, ami
a legbiztosabb jele egy termék népszerűségének?</p>

<p>Az egyik kétségtelen ok a gyorsaság. Az Nginx statikus fájlok kiszolgálásában és proxyként is sokkal nagyobb sebességgel szolgál ki
elődjeinél. A Wordpress.com <a href="http://highscalability.com/blog/2012/9/26/wordpresscom-serves-70000-reqsec-and-over-15-gbitsec-of-traf.html">mérései</a> szerint - megfelelő gép mellett - az átlagos 70000 req/s simán elérhető vele.</p>

<p>Ennek az egyik oka az, hogy az Nginx nem feltétlenül forkol mindig külön processzt vagy szálat az új kapcsolatoknak, ahogy pl. az Apache
egyes feldolgozómoduljai (prefork, ITK) teszik, sőt erre nincs is szüksége, mert eseményalapú a feldolgozása, így nem csak több kapcsolatot,
de több eseményt is le tud egyetlen feldolgozó szál kezelni. Ennek köszönhető egyébként az is, hogy hasonló terhelés mellett a memóriaigénye
messze elmarad a klasszikus webszerverekétől. Erről bővebben <a href="http://www.ichilton.co.uk/blog/web/nginx-and-why-you-should-be-running-it-instead-of-or-at-least-in-front-of-apache-380.html">itt</a> lehet olvasni.</p>

<p>A másik oka az, hogy az Nginx sokkal agresszívebben cachel a memóriában az elődjeinél. Megfelelő konfigurálás és többé-kevésbé fix (nem, vagy ritkán
változó) tartalom mellett elérhető az, hogy gyakorlatilag a memóriából történjen a kiszolgálás.</p>

<p>A pufferelés egyébként nagyon sokrétűen konfigurálható, ugyanakkor nem a legkönnyebben emészthető téma.</p>

<p>Előnye még a jó minőségű dokumentáció. A legtöbb modulnak nagyon részletes dokumentációja van, néhány konkrét használati eseteket is bemutat,
mely teljes biztonsággal átvehető egy az egyben a saját konfigurációnkba.</p>

<p>További előnyeként szokták sorolni a konfigurációs fájl könnyű érthetőségét. Akik valamilyen C szintaxisú nyelvben (PHP, Perl, C/C++, Java, stb)
programoznak, azoknak nagyon is ismerős lehetnek a blokkok és a sorvégi pontosvesszök, melyekből a konfiguráció felépül.</p>

<p><em>A következő cikkben az Nginx és a PHP kapcsolatát fogom bemutatni, és példákon keresztül szemlélteni</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Avatar történelem]]></title>
    <link href="http://hron.me/blog/2012/12/avatar-tortenelem/"/>
    <updated>2012-12-21T08:59:00+01:00</updated>
    <id>http://hron.me/blog/2012/12/avatar-tortenelem</id>
    <content type="html"><![CDATA[<p>Este újra megnéztem az Avatar-t, éjjel pedig furcsa álmom volt. Gyakorlatilag továbbálmodtam a történetet, pedig ez ritka eset nálam.</p>

<p>Szóval, a sztori lényege az, hogy Jake, miután az emberek többsége elhagyja a bolygót, két ottmaradt tudóssal nekiáll felfedezni azt. Az gondolom
már a filmből is mindenki számára világos volt, hogy ez gyakorlatilag egy hatalmas, dúsan burjánzó dzsungel. Ami nem, az az, hogy a bolygón
vannak olyan helyek, "szent helyek", ahova még a Navik se mennek túl sűrűn. Jake bemerészkedik az egyik ilyen helyre (amit persze a népe nem igazán helyesel,
de nem igazán tiltják meg, bár figyelmeztetik őt a veszélyre). Mint kiderül, ezek a helyek valójában romok, egy fejlett, de letűnt civilizáció romjai.</p>

<p>Ha hasonlítani kellene, akkor a földi dél-amerikai civilizációhoz hasonlítanám, azonban annál sokkal fejlettebb, idősebb civilizációról van szó. Azt tudjuk,
hogy a ma ismert Navik együtt élnek a természettel, igyekeznek minél kevesebb kárt okozni. Nos, elődeik kapcsolata a természettel ennél sokkal bonyolultabb
volt. Bár ők is természetimádó nép voltak, azért az nem okozott nekik gondot, hogy a nagy erdőségekből kis ligeteket csináljanak, miközben terjeszkedtek.</p>

<p>No, de vissza a sztorihoz. Szóval Jake bemerészkedik az egyik ilyen romba, felderíti, és találnak pár érdekes leletet, köztük néhány vésetekkel teli kőtáblát.
Ezeken főképp képek láthatóak, írás szinte alig, de annyit azért sikerül kiolvasni belőle, hogy itt egy fejlett civilizáció lakott, elég nagy lélekszámmal.
Találtak néhány térképet is a holdról, illetve olyan szintű leírásokat az óriásbolygóról, ami egyértelművé teszi, hogy űrutazásra képes fajról van szó.</p>

<p>Egy másik romban, találnak egy furcsa, fallal lezárt helységet. Majd' egy hónapjuk rámegy, mire sikerül kitalálni, hogy jussanak be. Bent két asztalt találnak,
két-két székkel, a mennyezeten pedig fura díszítésű panelek lógnak a két asztal felett. Az egyik kutató, aki korábban azt próbálta meg kitalálni, hogy milyen jellegű
mezőgazdasága volt a civilizációnak, fáradtan roskadt le az egyik székre... majd meglepően gyorsan el is aludt. Néhány perc múlva felébredt, és elmondta, hogy rájött
a megoldásra, ilyen és ilyen eszközöket használtak, stb. Mivel erre vonatkozóan eddig semmilyen bizonyítékot nem leltek, persze mindenki kételkedett a szavában.
Pár nappal később azonban felfedeztek pár mezőgazdasági témájú vésetet, ami pontosan megfelelt a kutató által vázoltaknak. Néhány további kísérlet után rájöttek, hogy
a szoba egyfajta tudástárként működik, letölti a betérő fejébe azokat a válaszokat, melyekre kiváncsi.</p>

<p>Jake közben talál egy kötáblát, tele neveknek és dátumoknak tűnő vésetekkel. Ő is kipróbálja a szobát, és valami különös történik...</p>

<p>Az a tábla valóban neveket tartalmazott, méghozzá különböző uralkodók neveit. Amikor Jake leül a szobában, egy név jár folyamatosan a fejében, a szoba pedig hozzáférhetővé
teszi számára ezen uralkodó naplóját. Mint kiderül, a Navik ősei nem volt egységes faj, az egyes klánok közt folyamatos volt a viszálykodás. Az az uralkodó, akinek a
naplójához Jake hozzáfért, az utolsók egyike volt. A faj hosszú életű volt, a száz helyi év teljesen átlagos kornak számított, a mai embernél talán valahol 50-60 évnek felel meg.
Az uralkodó naplójába gondosan feljegyezte az általa vívott harcok minden eseményét. Pusztító harcok voltak ezek, rengeteg áldozattal. A naplóbejegyzésekből azonban az is kiderül,
hogy írójuk belefásult a harcba, értelmetlennek találja, ő maga már nem is nagyon támadt, csak a városát védelmezte. Mivel tisztában van azzal, hogy nem győzhet, összedob egy csapatot nőkből és gyerekekből, akiket beküld az egyik erdőbe. Pár évvel később egy - közelebbről meg nem nevezett - fegyver elpusztítja az egész civilizációt, a naplót író uralkodó is teljesen véletlenül menekül meg.</p>

<p>Csatlakozik a menekültek csapatához, és elhatározzák, hogy újrakezdik, de az alapoktól. Megtiltja, hogy visszamenjenek a romokhoz (nem mintha nagyon lenne miért...), és
elkezdenek az ősi módon élni, gyűjtögetni, vadászni... Ő maga is csak egyszer megy vissza - a halála előtt nem sokkal -, hogy befejezze a naplóját.</p>

<p>A Navik faja tehát újrakezdés, visszatértek ősi gyökereikhez, és teljesen elfeledték a múltat.</p>

<p>Jake és csapata úgy dönt, hogy erről nem szólnak a Naviknak. Ha egyszer maguktól megtalálják a tudástárt, hát legyen, de nem látják értelmét annak, hogy ezt a népet
megbolygassák ilyen szörnyű emlékekkel.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails - polimorf világ]]></title>
    <link href="http://hron.me/blog/2012/12/rails-polimorf-vilag/"/>
    <updated>2012-12-13T07:23:00+01:00</updated>
    <id>http://hron.me/blog/2012/12/rails-polimorf-vilag</id>
    <content type="html"><![CDATA[<p>Azért vannak dolgok, amikkel lehet szépeket szívni.</p>

<p>A feladat valami olyasmi volt, hogy kell egy újrafelhasználható "cím" osztály, ami külön táblára is képeződne le, hogy ne a megfelelő táblákat terheljük feleslegesen, plusz a címek amúgy se mindig kellenek pl. a felhasználókezeléshez. Azért kell újrafelhasználhatónak lennie, mert két különböző dolog is használ címeket a rendszerben.</p>

<p>Nem akarom nagyon húzni az időt, az alábbi kód született rá:</p>

<p>```ruby Polimophic user profile
class Address &lt; ActiveRecord::Base
  belongs_to :addressable, :polymorphic => true
end</p>

<p>class User &lt; ActiveRecord::Base
  has_many  :addresses, :as => :addressable
  has_one   :billing_address , :as => :addressable, :class_name => 'Address', :conditions => { :billable => true, :shippable => false }
  has_one   :shipping_address, :as => :addressable, :class_name => 'Address', :conditions => { :shippable => true, :billable => false }
end
```</p>

<p>Erre kedves barátom azt mondaná, hogy szép baleset. És akkor még nagyon finoman fogalmazna. Nézzük, mik azok a buktatók, amin át lehet esni egy ilyet nézve:</p>

<ul>
<li>A has_many asszociáció ugye azért kell, hogy legyen valami, ami polimorf. Elvben bele lehet suvasztani a has_one mellé is, de nekem egyébként is kell tudnom a címeket egyben
lekérni, akkor meg miért ne emelném ki?</li>
<li>Az előbbi asszociáció alapján definiálunk két hozzárendelést. Ugye itt a hangsúly a :conditions hashen van, ez mondja meg, hogy a polimorf tömbből mely adatok kellenek
(pontosabban, hogy az asszociáció alapján generált query-ben a WHERE feltétel hogyan bővüljön)</li>
<li>Az egyik trükk az, hogy mindenképp meg kell adni az osztályt is, ugyanis a has_one asszociáció <em>nem</em> kéri le ezt az infót a hivatkozott polimorf asszociációtól, hanem saját
maga áll neki találgatni - természetesen rosszul.</li>
<li>A másik trükk pedig, hogy mivel ez egy kétparaméteres, egymást kölcsönösen kizáró feltétel, így <em>mindkettőt</em> meg kell adni, különben létrehozáskor előjöhet olyan csúfság, hogy
valaki meghinteli a dupla false-t - vagyis úgy mentünk el pl. egy billing címet, hogy az elvész az :addresses tömb nevű fekete lyukban (van értelme amúgy a dupla false-nak is,
csak abból nem billing meg shipping címek lesznek, hanem csak címek). Azaz, mentéskor a billing_address-en keresztül mentünk, de a mentés után a billing_address pont ugyanolyan
<code>nil</code> lesz, mint előtte volt vala.</li>
</ul>


<p>Azért ezzel is sikerült egy jó órát szívni...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMine és TeamCity]]></title>
    <link href="http://hron.me/blog/2012/11/rubymine-es-teamcity/"/>
    <updated>2012-11-11T11:08:00+01:00</updated>
    <id>http://hron.me/blog/2012/11/rubymine-es-teamcity</id>
    <content type="html"><![CDATA[<p>Már régóta keresek egy olyan IDE-t, ami képes nem csak projektszinten kezelni és szintaxis-kiemelést adni a Ruby/Rails projektjeimnek,
de magát a nyelvet is "beszéli", vagyis van például kódkiegészítés, refaktorálás, figyelmeztetések, etc, etc.
Az általam eddig ismert legkomolyabb IDE, a NetBeans is csak elég alapszinten beszélte a Ruby nyelvet - aztán ki is vették belőle a támogatást,
jelenleg a plugin folyamatosan haláltusáját vívja, 7.2-höz már meg sem jelent semmiféle verzió.</p>

<p>Egy StackOverflow böngészés során akadtam rá a JetBrains <a href="http://www.jetbrains.com/ruby/">RubyMine</a> nevű IDE-jére. Saját bevallásuk szerint az
eszköz képes nyelvi szinten is kezelni a Ruby-t, illetve támogatja az összes nagyobb teszkörnyezetet. Mivel amúgy is épp indítottam egy projektet,
úgy gondoltam, adok neki egy esélyt, hát legfeljebb letörlöm, és folytatom az eddigi módon, TextMate és Vim párossal. Szerencsére csalódtam. Pozitívan.
Hatalmasat.</p>

<p>A RubyMine ugyanis nem csak egyszerűen jó, hanem - amennyire tudom - a maga nemében jelenleg páratlan a piacon azzal, hogy tényleg hozza azt, amit ígér,
vagyis teljes mértékben támogatja a Ruby nyelvet és a Rails keretrendszert, sőt, még ennél is tovább megy, beépített támogatása van a lokalizációk kezeléséhez,
grafikusan mutatja, hogy mely mdoeljeink vannak adatbázisban, képes a Rails projekt szerkezetét Rails-aspektusú nézetben mutatni (ahol nem mappák és fájlok vannak,
hanem kategóriák, pl. Controllers, Models, Helpers), a kontrollerek akcióihoz hozzá tudja rendelni a nézeteket, partialokat, a refaktor során pedig olyan mélységekbe is
lemegy, amiről álmodni sem mertem soha - egy modell átnevezésekor képes a nézetekben is utánanézni az útvonal metódusoknak, és megfelelően átnevezni azokat!</p>

<p>Ezen felül csak úgy mellékesen, képes kezelni az <a href="http://rvm.io">RVM</a>-et, támogatja a <a href="http://gembundler.com/">Bundler</a>t, a Rails generátorokat, a Rake taszkokat, SCSS-t meg CoffeeScript-et, ... meg ilyen kis semmiségeket is.</p>

<p>Az egyetlen probléma vele a kissé hiperaktív kódkiegészítése, ha leírok egy nyilat, rögtön ugrana rá, pedig én magamtól szoktam szóközt is ütni utána, de azzal meg
elfogadom az első lehetőséget is egyben - ami általában rossz ötlet. Biztos le lehet valahogy beszélni róla, majd utánanézek (de ha valaki tudja a tuti megoldást,
a komment doboz mindig nyitott az ilyesmikre :-) ), egyelőre még elviselem.</p>

<p>Jelenleg folyamatosan használom az épp aktív projektemhez, teljesen jól szolgál, bár még képességeinek csak szerény részét használom. Most egyelőre a 30 napos
próbaidőszakban vagyunk (dicséretes, hogy ez alatt sem ugrál föl valami kis ablak indításkor, hogy még 22.45 nap van hátra, és mostazonnal vedd meg - ez rém undorító,
ha tetszik, úgyis megveszem - főleg, mert lejár -, ha meg nem tetszik, akkor ez a kapacitálás csak ront a dolgon), ám azt gondolom, hogy a 66 euro a személyes licencért abszolút megéri.</p>

<p>Amit nem használok belőle (sem), az a Git integráció, nekem a git még mindig parancssoros dolgot jelent, egyszerűbb kiadni a <code>git co feature-awesome-stuff</code> parancsot,
mint GUI-ban kikattintgatni. Legalábbis szerintem.</p>

<p>A JetBrains honlapját tallózgatva (ismét) ráakadtam a <a href="http://www.jetbrains.com/teamcity/">TeamCity</a> nevű CI szerverre is, ezzel egyszer volt már egy futó kapcsolatom, de
valamiért nem sikerült telepíteni, és a végén Jenkins lett belőle. Most ismét kapott tőlem egy lehetőséget, hogy elinduljon, és meggyőzzön. Ezúttal mindkettő sikerült is neki.</p>

<p>A TeamCity-ről azt érdemes tudni, hogy egy olyan Continous Integration szerver (továbbiakban CI szerver), melyet nagyon egyszerű kezelni, és nagyon jól áttekinthető felületet
ad, még egy felületes szemlélő számára is (ezt muszáj volt elsütni :-) ).</p>

<p>A RubyMine fejlesztők blogján pedig találtam egy <a href="http://blog.jetbrains.com/ruby/2009/11/jetbrains-teamcity-continuous-integration-for-ruby/">írást</a>, mely borzasztóan felcsigázta a kíváncsiságomat.
Azt merték ugyanis állítani, hogy  TeamCity beépítetten képes kezelni a RSpec és a Cucumber tesztek kimenetét, arrol riportot készít, hibáról értesít. Plusz, a TeamCity beépítetten támogatja az XMPP alapú notifikációt, amit pl. a Jenkins csak pluginnel tud.</p>

<p>Sajnos a TeamCity egyik hiányossága, hogy ő viszont már csak korlátozott mértékben képes kezelni a Bundlert: képes felismerni a létét, és azon keresztül futtatni a rake taszkokat, de már pl. egy <code>bundle install</code> -t képtelen elengedni, azt kézzel kell egy külön Build Step-ben, viszonylag kacifántosan megoldani. Végül sikerült, de azért nem voltam felhőtlenül boldog.
Viszont az első teszteredmények feledtették velem az ezen a téren történt csalódást, mert pontosan azt kaptam, amit elvártam: mindenféle külön konfiguráció nélkül jelenítete meg a Cucumber es RSpec tesztek eredményét, ráadásul egy egészen barátságos felületen.</p>

<p>Tényleg nem JetBrains reklámnak szánom ezt a postot, de azért annyira érződik mindkét terméken, hogy ezeket olyanok fejlesztik, akik láttak már közelről Rails projektet, meg RVM-et, meg ilyesmit... például a Jenkins Ruby pluginjénél nem volt ilyen érzésem.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guard - projektjeink testőre]]></title>
    <link href="http://hron.me/blog/2012/10/guard-projektjeink-testore/"/>
    <updated>2012-10-23T14:37:00+02:00</updated>
    <id>http://hron.me/blog/2012/10/guard-projektjeink-testore</id>
    <content type="html"><![CDATA[<p>Nem olyan régen ismerkedtem meg a <a href="https://github.com/guard/guard">guard</a> nevű
gemmel, ami egy nagyon hasznos kis szerszám annak, aki Rails fejlesztésre adja
a fejét, de plug-injei révén például PHP fejlesztők is profitálhatnak a tudásából.</p>

<!-- more -->


<p>Ez a kis cucc arra képes, hogy figyelje a projekt fájljait változások után
kutatva, és amikor változik valami, pl. elmentünk egy fájlt, akkor végre tud
hajtani bizonyos műveleteket.</p>

<p>Vegyünk két nagyon alap kis példát:</p>

<p>Van egy PHP projektünk, melyben PHPunit teszteket szeretnénk futtatni. Minden
egyes osztályunkhoz tartozik, egy hasonló nevű teszt osztály, csak Test van a
végén. Tehát a User -t a UserTest, a Car-t a CarTest osztály teszteli. Ekkor:</p>

<p>```ruby Guard konfiguráció PHPUnit-hoz https://github.com/guard/guard-phpunit Több infó
guard 'phpunit', :tests_path => 'Tests', :cli => '--colors' do
  # Figyeljük az összes teszt osztály változását
  watch(%r{<sup>.+Test.php$})</sup></p>

<p>  # Figyeljük az osztályok változását, és futtatjuk a megfelelő teszteket
  watch(%r{<sup>Classes/(.+).php})</sup> { |m| "Tests/#{m[1]}Test.php" }
end
```</p>

<p>Nem kell aggódni, ha a második esetnél az adott teszt osztály nem létezik,
akkor egyszerűen nem történik semmi.</p>

<p>A Guard-hoz rengeteg féle <a href="https://github.com/guard">plug-in</a> létezik már,
de legrosszabb esetben lehetséges shell parancsokat is <a href="https://github.com/guard/guard-shell">futtatni</a>
fájlváltozáskor.</p>

<p>Amire érdemes odafigyelni, az a függőségek. A Guard-nak egyrészt szüksége
van a platformunknak megfelelő fájlváltozás-érzékelő plug-inre, illetve
mivel képes minden platformon a platformnak megfelelően értesítést is
küldeni, így ezeket a plug-injeit is megfelelően konfigurálni kell.</p>

<p>Néhány dolog, amire figyelni kell:</p>

<ul>
<li>Mac OS X 10.8-nél korábbi verziólnál szükséges a <a href="http://growl.info">Growl</a> telepítése
(10.8-hoz van plug-in a beépített értesítési rendszer használatára)</li>
<li>Windows alatt a <a href="https://github.com/luislavena/win32console">win32console</a> gem nélkül nincsenek színek</li>
</ul>


<p>Emiatt én mindig Gemfile segítségével telepítem. Egy alap Gemfile álljon itt ehhez:</p>

<p>```ruby Gemfile Guard használatához
group :development do
  # Guard
  gem 'guard', '~> 1.4.0'
  if RUBY_PLATFORM =~ /darwin/i</p>

<pre><code>if %x{sw_vers -productVersion}.strip =~ /^10\.8/
  gem 'terminal-notifier-guard'
else
  gem 'ruby_gntp'
end
gem 'rb-fsevent', '~&gt; 0.9.1', :require =&gt; false
</code></pre>

<p>  elsif RUBY_PLATFORM =~ /linux/i</p>

<pre><code>gem 'rb-inotify', :require =&gt; false 
</code></pre>

<p>  elsif RUBY_PLATFORM =~ /(mswin|mingw)/i</p>

<pre><code>gem 'win32console', :require =&gt; false
gem 'wdm', :require =&gt; false
</code></pre>

<p>  end</p>

<p>  # Guard plug-ins
  gem 'guard-phpunit'
end
```</p>

<p>A függőségek telepítése a <code>bundle install</code> míg a Guard futtatása a <code>bundle exec guard start</code> paranccsal zajlik.</p>

<p>A Guard fájlt használatba vétel előtt inicializálni is kell, ezt a <code>bundle exec guard init</code> paranccsal tehetjük meg.
Ha menet közben telepítünk olyan plug-int, mely futtatásra alkalmas (tehát nem értesítő plug-in), akkor azt a
<code>bundle exec guard init PLUGIN_NAME</code> paranccsal tehetjük meg, a plug-in neve pedig mindig a guard- után álló rész (pl. shell).
Egyébként a legtöbb plug-in README fájlja nagyon részletes útmutatót tartalmaz a plug-in használatáról.</p>
]]></content>
  </entry>
  
</feed>
