<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Hron's blog]]></title>
  <link href="http://hron.me/blog/tags/git/atom.xml" rel="self"/>
  <link href="http://hron.me/"/>
  <updated>2014-04-03T07:24:12+02:00</updated>
  <id>http://hron.me/</id>
  <author>
    <name><![CDATA[Gábor Garami]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gitiles Install Howto]]></title>
    <link href="http://hron.me/blog/2013/01/gitiles-install-howto/"/>
    <updated>2013-01-30T17:12:00+01:00</updated>
    <id>http://hron.me/blog/2013/01/gitiles-install-howto</id>
    <content type="html"><![CDATA[<p>I sucked a bit with <a href="https://code.google.com/p/gitiles/">Gitiles</a>, Gerrit's Gitweb implementation, because this project lacks an INSTALL file.</p>

<p>So, basically you have to do following:</p>

<ul>
<li><p>First, check out of the source:</p>

<p> <code>git clone https://gerrit.googlesource.com/gitiles</code></p></li>
<li><p>After you cloned the source, compile it with <a href="http://maven.apache.org/">Maven</a>:</p>

<p> <code>mvn package -Dmaven.test.skip=true</code></p></li>
</ul>


<p>  Now, you got <strong>gitiles-war-1.0-SNAPSHOT.war</strong> in gitiles-war/target folder. Deploy it under your application server, in this case I put it to Jetty's webapps folder.</p>

<ul>
<li>Tricky part is coming: you will faced with an error message, what says some configuration options are missing. This is because you didn't created any configuration file yet. By default, webapp searches its configuration in the webapp root folder, but - because jetty explodes this folder every restart, I decided to put it to some more persistent place. I am do not run any other thing under this Jetty than Gerrit and Gitiles, so I created the gitiles.config under Jetty's etc folder:</li>
</ul>


<p>```text gitiles.config
[gitiles]</p>

<pre><code># Repositories placed here
basePath = /srv/git/repositories
# Do not check they are exported
exportAll = true
# This URL will be displayed as clone URL. DO NOT FORGET TRAILING SLASH!
baseGitUrl = ssh://cr.hron.me:29418/
# Title of site (doh)
siteTitle  = Gitiles - kingmax.hron.me:/srv/git/repositories
# I dunno why, but it is have to be configured.
canonicalHostName = kingmax.hron.me
</code></pre>

<p>```</p>

<ul>
<li>The config file above is cool, but Gitiles still crying... yeah, because you have to tell where it should find that. To do this, you must export a System property <strong>com.google.gitiles.configPath</strong>. I was <em>very</em> lazy, so I edited jetty.xml and before last closing tag I pasted this:</li>
</ul>


<p>```xml jetty.xml</p>

<pre><code>&lt;Call class="java.lang.System" name="setProperty"&gt;
    &lt;Arg&gt;com.google.gitiles.configPath&lt;/Arg&gt;
    &lt;Arg&gt;&lt;SystemProperty name="jetty.home" default="." /&gt;/etc/gitiles.config&lt;/Arg&gt;
&lt;/Call&gt;
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A legjobb Git workflow - továbbfejlesztve]]></title>
    <link href="http://hron.me/blog/2012/04/a-legjobb-git-workflow-tovabbfejlesztve/"/>
    <updated>2012-04-18T23:06:00+02:00</updated>
    <id>http://hron.me/blog/2012/04/a-legjobb-git-workflow-tovabbfejlesztve</id>
    <content type="html"><![CDATA[<p>Közönségkérésre, most bevezetem az olvasóimat abba a Git repo kezelési módszertanba, amit a saját projektjeimnél használok.</p>

<p>Alapul az egyik talán legnépszerűbb Git workflow szolgált, melynek leírása <a href="http://nvie.com/posts/a-successful-git-branching-model/" title="A successful git branching model">itt tekinthető meg</a>.</p>

<!-- more -->


<p>Lássuk az alapfogalmakat, amiket a leírásban használni fogok, ez az én terminológiám:</p>

<ul>
<li><strong>Master branch</strong>: A repo alapértelmezett branche. A frissen létrehozott git repo-nál ez a "master" nevű branch, de akárhogy is lehet hívni.</li>
<li><strong>Develop branch</strong>: Ezen az ágon folyik a fejlesztés, de közvetlenül ide általában nem commitolunk (lsd. később)</li>
<li><strong>Feature branch</strong>: egy új feature fejlesztése zajlik  rajta. Ez lehet egy új gomb és a mögöttes kód, lehet a tesztek írására  szolgáló branch, a lényeg, hogy az itt zajló változások vagy új  funkcionalitást adnak a projekthez, vagy annyira jelentősen módosítanak  egy meglevő funkcionalitást, ami már nem fér bele a hotfix branchekbe.</li>
<li><strong>Hotfix branch</strong>: Ide elsősorban hibajavítások jönnek,  amelyek jöhetnek valamilyen bugtrackerből, vagy akár bemondásra is, ez  már egyéni metodika kérdése. A lényeg: ide olyan változtatás nem  küldhető be, mely nagy mértékben változtat a funkcionalitáson.</li>
</ul>


<p>Szóval. amikor indul a repo életciklusa, akkor létrejön a master  branch. A kezdő commit általában vagy egy .gitignore fájl beküldéséből  áll (ez a legtöbb esetben hasznos, ha megvan), vagy valami hasonló,  jelentéktelen változtatásból. Rails projekt esetében én azt szoktam  csinálni, hogy a legenerált és kitisztított projektfát küldöm be, amiben  még semmi nincsen, csak a mappák vannak létrehozva, illetve pár dolog  felkonfigurálva (pl. rspec, cucumber, meg hasonlók). Mindenesetre az  alkalmazás itt kezdi meg életciklusát.</p>

<p>Ez után rögtön le is ágaztatom a develop branchet, majd a develop  branchből az első feature branchet. Fontos, hogy minden feature és  hotfix branch a develop ágból származik.</p>

<p>A feature branchen elkezdem az első dolgokat implementálni, majd  amikor az első feature kész (pl. van egy belépő felület), akkor azt  rámergelem a develop branchre. A mergelések mindig szigorúan --no-ff  kapcsolóval történnek, mert ez biztosítja számunkra azt, hogy a későbbi  grafikus megjelenítéseknél jól elkülöníthetően látszódjon, hogy honnét  származik a változtatás.</p>

<p>Példa:</p>

<p><code>
myproject (feature-add-loginform) $ git checkout develop
myproject (develop) $ git merge --no-ff feature-add-loginform
</code></p>

<p>A hotfix branchekkel ugyanígy járok el.</p>

<p>Hogy ne legyen  konfliktus merge-léskor, a feature/hotfix brancheket időnként rebase-lem  a develop-hoz (csak ahhoz), hogy meglegyenek azok a változások is,  amelyeket más branchen követtem el. Ez ugye pl. webalkalmazásnál fontos,  hogy ha a dizájnon változás van, vagy a js-hez új funkcionalitás  került, akkor azt egy, ettől függelten feature fejlesztése során is  tudjam használni (tipikus példa erre az a pont, amikor az átmeneti  combobox-okat leváltja egy automatikus kiegészítés alapú megoldás). Ez  egyrészt kényelmi okokból fontos, másrészt pedig azért, mert ilyenkor  már zajlik a <em>dogfooding</em>, vagyis a saját kód felhasználói  szempontból történő tesztelése. Volt már, hogy itt jöttek elő olyan  hibák, melyeket sem a tesztek, sem az első kattintgatások nem hoztak ki.</p>

<p>Van néhány olyan eset, amikor közvetlenül a develop ágra commitolok. A legfőbb szempont ilyenkor, hogy ez csak olyan változás lehet, ami nagyon kevés fájlt érint, illetőleg a branchek nagy részének fontos változtatás. Ilyen lehet például a .gitignore fájl felbővítése, ha valaki hirtelen boldog Mac tulajdonos lesz, és a Mac fájlrendszer csodáit (.DS_Store) ki szeretnénk zárni a projektből. De ilyen lehet az is, amikor egy általunk elkövetett elütést javítunk ki egy nyelvi fájlban, mert erre pl. felesleges lehet egy új branchet szülni. Persze ez a fejlesztő/fejlesztők által követett módszertantól is erősen függhet.
Ilyenkor viszont fontos, hogy minden branch értesüljön a változásokról, és rebase-zel maga alá tegye azokat.</p>

<p>Amikor a projekt elérkezett egy <em>milestone</em>-hoz,  akkor történik a master branchre mergelés, közvetlenül a develop  branch-ről. Ha a projekt olyan, hogy ez szükséges, ilyenkor a master  branchen tagelek is (ez főleg azért érdekes, mert pl. a GitHub minden  tagelt branch-ből létrehoz egy letölthető forrás csomagot, így ezzel  nekem nem kell törődnöm).</p>

<p>A fő szempont a master-nél, hogy itt  mindig stabil, minden változtatástól mentes kód legyen, amely bármikor  bárhova deployolható, és azonnal működőképes.</p>

<pre><code>Érdekes kérdés,  hogy mi legyen azokkal a hotfix típusú változtatásokkal, amelyek a  master branchez kellene hogy menjenek, hiszen az éles alkalmazásban van a  hiba, ugynakkor a develop ágon már mergelve van egy feature, amit nem  szívesen mergelnénk rá a master ágra. Nos, én általában megpróbálok a  helyzethez igazodni. Először is, meg kell nézni, hogy az adott hiba  előjött-e már a develop ágon, és fixálva lett-e. Ha nem, akkor ez az  első lépés, plusz a megfelelő tesztesetek legyártása, hogy a  továbbiakban ilyen probléma elő ne fordulhasson.
</code></pre>

<p>Ha a hiba nem kritikus, a legegyszerűbb megoldás a hiba javítását a következő <em>milestone</em>-ig eltolni. De nyilván vannak kritkus hibák is, lássuk mi a teendő ezekkel.</p>

<p>A  legegyszerűbb eset, amikor még nem történt mergelés a develop-ra a  master ágra történt mergelés óta, ilyenkor simán át lehet venni a hotfix  branch javítását.</p>

<p>Más esetekben meg kell nézni, hogy a  hotfix által érintett fájlok milyen mértékben változtak a master-hez  képest. Erre a git diff parancs ad lehetőséget. Ha a fájl ettől a  változtatástól eltekintve nem változott, akkor a beküldött commit-nak  veszem a diff-jét (<code>git diff HEAD^..HEAD</code>), majd alkalmazom csak ezt a  javítást a master branchre. Ilyenkor a következő mergelésnél figyelni  kell, mert konfliktus léphet fel, ezt sajnos egyedileg le kell kezelni.</p>

<p>Egy másik megoldása a problémának, hogy mivel a master ág az gyakorlatilag a develop ág egy <em>snapshot</em>-ja,  így abból indítom a hotfix branchet, és mind a két ágra visszamergelem.  Ez talán a legegyszerűbb megoldása a problémának - csakhogy  tapasztalatom szerint ez az, ami a legritkábban is működik. Ugyanis  nincs értelme álmodozni, a master-ről indított hotfix branchek az esetek  nagy részében nem illeszkednek a develop ágra, conflict alakul ki, és  elég sok nyűg van, mire oda beilleszkedik, plusz utána a master-ra  történő mergeléskor megint kialakulhat conflict. Mindenesetre van, ahol  ez a megoldás is működik.</p>

<p>Alternatív megoldás lehet még a  cherry-pick használata, mellyel egy darab commit-ot tudunk a develop  branchből átvenni a masterre, a mergelés kockázata nélkül. Erről még  csak hallottam, nincs gyakorlatom vele, hogy milyen százalékban okozhat  conflict-ot, illetve hogy a --no-ff merge képes-e elkezelni az átvett  commit-ot. Illetve ez is csak akkor működik, ha nincsenek gyökeres  változások a develop ágban erre a fájlra nézve.</p>

<p>Amit a  commit-okról még érdemes elmondani: én mindig ún. topic commit-okat  használok. Ez azt jelenti, hogy mindig igyekszem olyan commit-okat  gyártani, amelyek önállóak, és pontosan egy dolgot csináljanak. Tehát ha  pl. teszteket írok, és közben születnek javítások is, amelyek a tesztek  lefutásához kellenek, nem nyitok mindig új hotfix branchet (mert egy  lusta disznó vagyok), hanem a tesztek ágába belerakom a változást is.  Mivel a tesztek az appra nézve nem jelentenek funkcionális változást, a  javítás viszont igen, így én nem érzem azt, hogy ennek kockázata lenne.  Ellenben nagyon fontos ügyelni arra, hogy ilyenkor mindig pontosan  azokat a változtatásokat küldjük be, amelyeket azzal a committ-tal  javítunk. Ha kell, <em>hunk</em> (ez a változtatások egysége, a diff  kimenetében egy, három kukaccal kezdődő sorral szeparált blokk) szinten  bontom szét a változásokat. Erre nagyon jó lehetőséget ad a git add  parancs -p kapcsolója.
Ennek a megoldásnak a legfőbb haszna az, hogy  bárhol meg lehet bontani a develop branchet, bárhol le lehet ágaztatni róla egy új branchet, mindig viszonylag konzisztens állapotot fogunk kapni.</p>

<p>Összességében tehát a legfőbb alapelvek:</p>

<ul>
<li>A master branchre lehetőleg csak mergelés történjen, ide közvetlenül (a kezdő commit-tól eltekintve) ne küldjünk semmit.</li>
<li>A develop branch-en lehet játszani, de érdemes figyelni a konzisztenciájára</li>
<li>Hotfix branchen a működést alapjaiban érintő változtatás nem történhet</li>
<li>Mind a hotfix mind a feature brancheket érdemes frissen tartani a develop-hoz képest, hogy ne érjenek minket nagy meglepetések</li>
</ul>


<p>Véleményeket itt alul lehet írni, ahogy időm engedi reagálni fogok rájuk.</p>
]]></content>
  </entry>
  
</feed>
